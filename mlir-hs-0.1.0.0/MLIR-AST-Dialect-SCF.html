<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>MLIR.AST.Dialect.SCF</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">mlir-hs-0.1.0.0</span><ul class="links" id="page-menu"><li><a href="src/MLIR.AST.Dialect.SCF.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">MLIR.AST.Dialect.SCF</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">condition</a></li><li><a href="#g:2">execute_region</a></li><li><a href="#g:3">for</a></li><li><a href="#g:4">if</a></li><li><a href="#g:5">parallel</a></li><li><a href="#g:6">reduce</a></li><li><a href="#g:7">reduce.return</a></li><li><a href="#g:8">while</a></li><li><a href="#g:9">yield</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:condition">condition</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a></li><li class="src short"><a href="#v:execute_region">execute_region</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:for">for</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:if_">if_</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:parallel">parallel</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><a href="#v:reduce">reduce</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m ()</li><li class="src short"><span class="keyword">pattern</span> <a href="#v:ReduceReturn">ReduceReturn</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:reduce_return">reduce_return</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a></li><li class="src short"><a href="#v:while">while</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a></li><li class="src short"><span class="keyword">pattern</span> <a href="#v:Yield">Yield</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; [operand] -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand</li><li class="src short"><a href="#v:yield">yield</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>condition</h1></a><div class="doc"><p>This operation accepts the continuation (i.e., inverse of exit) condition
 of the <code>scf.while</code> construct. If its first argument is true, the &quot;after&quot;
 region of <code>scf.while</code> is executed, with the remaining arguments forwarded
 to the entry block of the region. Otherwise, the loop terminates.</p></div><div class="top"><p class="src"><a id="v:condition" class="def">condition</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a> <a href="src/MLIR.AST.Dialect.Generated.SCF.html#condition" class="link">Source</a> <a href="#v:condition" class="selflink">#</a></p><div class="doc"><p>A builder for <code>scf.condition</code>.</p></div></div><a href="#g:2" id="g:2"><h1>execute_region</h1></a><div class="doc"><p>The <code>execute_region</code> operation is used to allow multiple blocks within SCF
 and other operations which can hold only one block.  The <code>execute_region</code>
 operation executes the region held exactly once and cannot have any operands.
 As such, its region has no arguments. All SSA values that dominate the op can
 be accessed inside the op. The op's region can have multiple blocks and the
 blocks can have multiple distinct terminators. Values returned from this op's
 region define the op's results.</p><p>Example:</p><pre>scf.for %i = 0 to 128 step %c1 {
  %y = scf.execute_region -&gt; i32 {
    %x = load %A[%i] : memref&lt;128xi32&gt;
    scf.yield %x : i32
  }
}

affine.for %i = 0 to 100 {
  &quot;foo&quot;() : () -&gt; ()
  %v = scf.execute_region -&gt; i64 {
    cf.cond_br %cond, ^bb1, ^bb2

  ^bb1:
    %c1 = arith.constant 1 : i64
    cf.br ^bb3(%c1 : i64)

  ^bb2:
    %c2 = arith.constant 2 : i64
    cf.br ^bb3(%c2 : i64)

  ^bb3(%x : i64):
    scf.yield %x : i64
  }
  &quot;bar&quot;(%v) : (i64) -&gt; ()
}
</pre></div><div class="top"><p class="src"><a id="v:execute_region" class="def">execute_region</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.SCF.html#execute_region" class="link">Source</a> <a href="#v:execute_region" class="selflink">#</a></p><div class="doc"><p>A builder for <code>scf.execute_region</code>.</p></div></div><a href="#g:3" id="g:3"><h1>for</h1></a><div class="doc"><p>The &quot;scf.for&quot; operation represents a loop taking 3 SSA value as operands
 that represent the lower bound, upper bound and step respectively. The
 operation defines an SSA value for its induction variable. It has one
 region capturing the loop body. The induction variable is represented as an
 argument of this region. This SSA value always has type index, which is the
 size of the machine word. The step is a value of type index, required to be
 positive.
 The lower and upper bounds specify a half-open range: the range includes
 the lower bound but does not include the upper bound.</p><p>The body region must contain exactly one block that terminates with
 &quot;scf.yield&quot;. Calling ForOp::build will create such a region and insert
 the terminator implicitly if none is defined, so will the parsing even in
 cases when it is absent from the custom format. For example:</p><pre>scf.for %iv = %lb to %ub step %step {
  ... // body
}
</pre><p><code>scf.for</code> can also operate on loop-carried variables and returns the final
 values after loop termination. The initial values of the variables are
 passed as additional SSA operands to the &quot;scf.for&quot; following the 3 loop
 control SSA values mentioned above (lower bound, upper bound and step). The
 operation region has an argument for the induction variable, followed by
 one argument for each loop-carried variable, representing the value of the
 variable at the current iteration.</p><p>The region must terminate with a &quot;scf.yield&quot; that passes the current
 values of all loop-carried variables to the next iteration, or to the
 &quot;scf.for&quot; result, if at the last iteration. The static type of a
 loop-carried variable may not change with iterations; its runtime type is
 allowed to change. Note, that when the loop-carried variables are present,
 calling ForOp::build will not insert the terminator implicitly. The caller
 must insert &quot;scf.yield&quot; in that case.</p><p>&quot;scf.for&quot; results hold the final values after the last iteration.
 For example, to sum-reduce a memref:</p><pre>func @reduce(%buffer: memref&lt;1024xf32&gt;, %lb: index,
             %ub: index, %step: index) -&gt; (f32) {
  // Initial sum set to 0.
  %sum_0 = arith.constant 0.0 : f32
  // iter_args binds initial values to the loop's region arguments.
  %sum = scf.for %iv = %lb to %ub step %step
      iter_args(%sum_iter = %sum_0) -&gt; (f32) {
    %t = load %buffer[%iv] : memref&lt;1024xf32&gt;
    %sum_next = arith.addf %sum_iter, %t : f32
    // Yield current iteration sum to next iteration %sum_iter or to %sum
    // if final iteration.
    scf.yield %sum_next : f32
  }
  return %sum : f32
}
</pre><p>If the &quot;scf.for&quot; defines any values, a yield must be explicitly present.
 The number and types of the &quot;scf.for&quot; results must match the initial
 values in the &quot;iter_args&quot; binding and the yield operands.</p><p>Another example with a nested &quot;scf.if&quot; (see &quot;scf.if&quot; for details) to
 perform conditional reduction:</p><pre>func @conditional_reduce(%buffer: memref&lt;1024xf32&gt;, %lb: index,
                         %ub: index, %step: index) -&gt; (f32) {
  %sum_0 = arith.constant 0.0 : f32
  %c0 = arith.constant 0.0 : f32
  %sum = scf.for %iv = %lb to %ub step %step
      iter_args(%sum_iter = %sum_0) -&gt; (f32) {
    %t = load %buffer[%iv] : memref&lt;1024xf32&gt;
    %cond = arith.cmpf &quot;ugt&quot;, %t, %c0 : f32
    %sum_next = scf.if %cond -&gt; (f32) {
      %new_sum = arith.addf %sum_iter, %t : f32
      scf.yield %new_sum : f32
    } else {
      scf.yield %sum_iter : f32
    }
    scf.yield %sum_next : f32
  }
  return %sum : f32
}
</pre></div><div class="top"><p class="src"><a id="v:for" class="def">for</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.SCF.html#for" class="link">Source</a> <a href="#v:for" class="selflink">#</a></p><div class="doc"><p>A builder for <code>scf.for</code>.</p></div></div><a href="#g:4" id="g:4"><h1>if</h1></a><div class="doc"><p>The <code>scf.if</code> operation represents an if-then-else construct for
 conditionally executing two regions of code. The operand to an if operation
 is a boolean value. For example:</p><pre>scf.if %b  {
  ...
} else {
  ...
}
</pre><p><code>scf.if</code> may also return results that are defined in its regions. The
 values defined are determined by which execution path is taken.</p><p>Example:</p><pre>%x, %y = scf.if %b -&gt; (f32, f32) {
  %x_true = ...
  %y_true = ...
  scf.yield %x_true, %y_true : f32, f32
} else {
  %x_false = ...
  %y_false = ...
  scf.yield %x_false, %y_false : f32, f32
}
</pre><p><code>scf.if</code> regions are always terminated with &quot;scf.yield&quot;. If &quot;scf.if&quot;
 defines no values, the &quot;scf.yield&quot; can be left out, and will be inserted
 implicitly. Otherwise, it must be explicit.
 Also, if &quot;scf.if&quot; defines one or more values, the 'else' block cannot be
 omitted.</p><p>Example:</p><pre>scf.if %b  {
  ...
}
</pre></div><div class="top"><p class="src"><a id="v:if_" class="def">if_</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.SCF.html#if_" class="link">Source</a> <a href="#v:if_" class="selflink">#</a></p><div class="doc"><p>A builder for <code>scf.if</code>.</p></div></div><a href="#g:5" id="g:5"><h1>parallel</h1></a><div class="doc"><p>The &quot;scf.parallel&quot; operation represents a loop nest taking 4 groups of SSA
 values as operands that represent the lower bounds, upper bounds, steps and
 initial values, respectively. The operation defines a variadic number of
 SSA values for its induction variables. It has one region capturing the
 loop body. The induction variables are represented as an argument of this
 region. These SSA values always have type index, which is the size of the
 machine word. The steps are values of type index, required to be positive.
 The lower and upper bounds specify a half-open range: the range includes
 the lower bound but does not include the upper bound. The initial values
 have the same types as results of &quot;scf.parallel&quot;. If there are no results,
 the keyword <code>init</code> can be omitted.</p><p>Semantically we require that the iteration space can be iterated in any
 order, and the loop body can be executed in parallel. If there are data
 races, the behavior is undefined.</p><p>The parallel loop operation supports reduction of values produced by
 individual iterations into a single result. This is modeled using the
 scf.reduce operation (see scf.reduce for details). Each result of a
 scf.parallel operation is associated with an initial value operand and
 reduce operation that is an immediate child. Reductions are matched to
 result and initial values in order of their appearance in the body.
 Consequently, we require that the body region has the same number of
 results and initial values as it has reduce operations.</p><p>The body region must contain exactly one block that terminates with
 &quot;scf.yield&quot; without operands. Parsing ParallelOp will create such a region
 and insert the terminator when it is absent from the custom format.</p><p>Example:</p><pre>%init = arith.constant 0.0 : f32
scf.parallel (%iv) = (%lb) to (%ub) step (%step) init (%init) -&gt; f32 {
  %elem_to_reduce = load %buffer[%iv] : memref&lt;100xf32&gt;
  scf.reduce(%elem_to_reduce) : f32 {
    ^bb0(%lhs : f32, %rhs: f32):
      %res = arith.addf %lhs, %rhs : f32
      scf.reduce.return %res : f32
  }
}
</pre></div><div class="top"><p class="src"><a id="v:parallel" class="def">parallel</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.SCF.html#parallel" class="link">Source</a> <a href="#v:parallel" class="selflink">#</a></p><div class="doc"><p>A builder for <code>scf.parallel</code>.</p></div></div><a href="#g:6" id="g:6"><h1>reduce</h1></a><div class="doc"><p>&quot;scf.reduce&quot; is an operation occurring inside &quot;scf.parallel&quot; operations.
 It consists of one block with two arguments which have the same type as the
 operand of &quot;scf.reduce&quot;.</p><p>&quot;scf.reduce&quot; is used to model the value for reduction computations of a
 &quot;scf.parallel&quot; operation. It has to appear as an immediate child of a
 &quot;scf.parallel&quot; and is associated with a result value of its parent
 operation.</p><p>Association is in the order of appearance in the body where the first
 result of a parallel loop operation corresponds to the first &quot;scf.reduce&quot;
 in the operation's body region. The reduce operation takes a single
 operand, which is the value to be used in the reduction.</p><p>The reduce operation contains a region whose entry block expects two
 arguments of the same type as the operand. As the iteration order of the
 parallel loop and hence reduction order is unspecified, the result of
 reduction may be non-deterministic unless the operation is associative and
 commutative.</p><p>The result of the reduce operation's body must have the same type as the
 operands and associated result value of the parallel loop operation.
 Example:</p><pre>%operand = arith.constant 1.0 : f32
scf.reduce(%operand) : f32 {
  ^bb0(%lhs : f32, %rhs: f32):
    %res = arith.addf %lhs, %rhs : f32
    scf.reduce.return %res : f32
}
</pre></div><div class="top"><p class="src"><a id="v:reduce" class="def">reduce</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m () <a href="src/MLIR.AST.Dialect.Generated.SCF.html#reduce" class="link">Source</a> <a href="#v:reduce" class="selflink">#</a></p><div class="doc"><p>A builder for <code>scf.reduce</code>.</p></div></div><a href="#g:7" id="g:7"><h1>reduce.return</h1></a><div class="doc"><p>&quot;scf.reduce.return&quot; is a special terminator operation for the block inside
 &quot;scf.reduce&quot;. It terminates the region. It should have the same type as
 the operand of &quot;scf.reduce&quot;. Example for the custom format:</p><pre>scf.reduce.return %res : f32
</pre></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:ReduceReturn" class="def">ReduceReturn</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; operand -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.SCF.html#ReduceReturn" class="link">Source</a> <a href="#v:ReduceReturn" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>scf.reduce.return</code>.</p></div></div><div class="top"><p class="src"><a id="v:reduce_return" class="def">reduce_return</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a> <a href="src/MLIR.AST.Dialect.Generated.SCF.html#reduce_return" class="link">Source</a> <a href="#v:reduce_return" class="selflink">#</a></p><div class="doc"><p>A builder for <code>scf.reduce.return</code>.</p></div></div><a href="#g:8" id="g:8"><h1>while</h1></a><div class="doc"><p>This operation represents a generic &quot;while&quot;/&quot;do-while&quot; loop that keeps
 iterating as long as a condition is satisfied. There is no restriction on
 the complexity of the condition. It consists of two regions (with single
 block each): &quot;before&quot; region and &quot;after&quot; region. The names of regions
 indicates whether they execute before or after the condition check.
 Therefore, if the main loop payload is located in the &quot;before&quot; region, the
 operation is a &quot;do-while&quot; loop. Otherwise, it is a &quot;while&quot; loop.</p><p>The &quot;before&quot; region terminates with a special operation, <code>scf.condition</code>,
 that accepts as its first operand an <code>i1</code> value indicating whether to
 proceed to the &quot;after&quot; region (value is <code>true</code>) or not. The two regions
 communicate by means of region arguments. Initially, the &quot;before&quot; region
 accepts as arguments the operands of the <code>scf.while</code> operation and uses them
 to evaluate the condition. It forwards the trailing, non-condition operands
 of the <code>scf.condition</code> terminator either to the &quot;after&quot; region if the
 control flow is transferred there or to results of the <code>scf.while</code> operation
 otherwise. The &quot;after&quot; region takes as arguments the values produced by the
 &quot;before&quot; region and uses <code>scf.yield</code> to supply new arguments for the
 &quot;before&quot; region, into which it transfers the control flow unconditionally.</p><p>A simple &quot;while&quot; loop can be represented as follows.</p><pre>%res = scf.while (%arg1 = %init1) : (f32) -&gt; f32 {
  /* &quot;Before&quot; region.
   * In a &quot;while&quot; loop, this region computes the condition. */
  %condition = call @evaluate_condition(%arg1) : (f32) -&gt; i1

  <em>* Forward the argument (as result or &quot;after&quot; region argument). *</em>
  scf.condition(%condition) %arg1 : f32

} do {
^bb0(%arg2: f32):
  /* &quot;After region.
   * In a &quot;while&quot; loop, this region is the loop body. */
  %next = call @payload(%arg2) : (f32) -&gt; f32

  /* Forward the new value to the &quot;before&quot; region.
   * The operand types must match the types of the <code>scf.while</code> operands. */
  scf.yield %next : f32
}
</pre><p>A simple &quot;do-while&quot; loop can be represented by reducing the &quot;after&quot; block
 to a simple forwarder.</p><pre>%res = scf.while (%arg1 = %init1) : (f32) -&gt; f32 {
  /* &quot;Before&quot; region.
   * In a &quot;do-while&quot; loop, this region contains the loop body. */
  %next = call @payload(%arg1) : (f32) -&gt; f32

  <em>* And also evaluates the condition. *</em>
  %condition = call @evaluate_condition(%arg1) : (f32) -&gt; i1

  <em>* Loop through the &quot;after&quot; region. *</em>
  scf.condition(%condition) %next : f32

} do {
^bb0(%arg2: f32):
  /* &quot;After&quot; region.
   * Forwards the values back to &quot;before&quot; region unmodified. */
  scf.yield %arg2 : f32
}
</pre><p>Note that the types of region arguments need not to match with each other.
 The op expects the operand types to match with argument types of the
 &quot;before&quot; region&quot;; the result types to match with the trailing operand types
 of the terminator of the &quot;before&quot; region, and with the argument types of the
 &quot;after&quot; region. The following scheme can be used to share the results of
 some operations executed in the &quot;before&quot; region with the &quot;after&quot; region,
 avoiding the need to recompute them.</p><pre>%res = scf.while (%arg1 = %init1) : (f32) -&gt; i64 {
  /* One can perform some computations, e.g., necessary to evaluate the
   * condition, in the &quot;before&quot; region and forward their results to the
   * &quot;after&quot; region. */
  %shared = call @shared_compute(%arg1) : (f32) -&gt; i64

  <em>* Evaluate the condition. *</em>
  %condition = call @evaluate_condition(%arg1, %shared) : (f32, i64) -&gt; i1

  /* Forward the result of the shared computation to the &quot;after&quot; region.
   * The types must match the arguments of the &quot;after&quot; region as well as
   * those of the <code>scf.while</code> results. */
  scf.condition(%condition) %shared : i64

} do {
^bb0(%arg2: i64) {
  /* Use the partial result to compute the rest of the payload in the
   * &quot;after&quot; region. */
  %res = call @payload(%arg2) : (i64) -&gt; f32

  /* Forward the new value to the &quot;before&quot; region.
   * The operand types must match the types of the <code>scf.while</code> operands. */
  scf.yield %res : f32
}
</pre><p>The custom syntax for this operation is as follows.</p><pre>op ::= <code>scf.while</code> assignments <code>:</code> function-type region <code>do</code> region
       </pre><p>attributes<code> attribute-dict
 initializer ::= <em>* empty *</em> | </code>(<code> assignment-list </code>)<code>
 assignment-list ::= assignment | assignment </code>,<code> assignment-list
 assignment ::= ssa-value </code>=<code> ssa-value
 </code></p></div><div class="top"><p class="src"><a id="v:while" class="def">while</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST.html#t:Type" title="MLIR.AST">Type</a>] -&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; <a href="MLIR-AST-Builder.html#t:RegionBuilderT" title="MLIR.AST.Builder">RegionBuilderT</a> m () -&gt; m <a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a> <a href="src/MLIR.AST.Dialect.Generated.SCF.html#while" class="link">Source</a> <a href="#v:while" class="selflink">#</a></p><div class="doc"><p>A builder for <code>scf.while</code>.</p></div></div><a href="#g:9" id="g:9"><h1>yield</h1></a><div class="doc"><p>&quot;scf.yield&quot; yields an SSA value from the SCF dialect op region and
 terminates the regions. The semantics of how the values are yielded is
 defined by the parent operation.
 If &quot;scf.yield&quot; has any operands, the operands must match the parent
 operation's results.
 If the parent operation defines no values, then the &quot;scf.yield&quot; may be
 left out in the custom syntax and the builders will insert one implicitly.
 Otherwise, it has to be present in the syntax to indicate which values are
 yielded.</p></div><div class="top"><p class="src"><span class="keyword">pattern</span> <a id="v:Yield" class="def">Yield</a> :: <a href="MLIR-AST.html#t:Location" title="MLIR.AST">Location</a> -&gt; [operand] -&gt; <a href="MLIR-AST.html#t:AbstractOperation" title="MLIR.AST">AbstractOperation</a> operand <a href="src/MLIR.AST.Dialect.Generated.SCF.html#Yield" class="link">Source</a> <a href="#v:Yield" class="selflink">#</a></p><div class="doc"><p>A pattern for <code>scf.yield</code>.</p></div></div><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="MLIR-AST-Builder.html#t:MonadBlockBuilder" title="MLIR.AST.Builder">MonadBlockBuilder</a> m =&gt; [<a href="MLIR-AST-Builder.html#t:Value" title="MLIR.AST.Builder">Value</a>] -&gt; m <a href="MLIR-AST-Builder.html#t:EndOfBlock" title="MLIR.AST.Builder">EndOfBlock</a> <a href="src/MLIR.AST.Dialect.Generated.SCF.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><p>A builder for <code>scf.yield</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.25.1</p></div></body></html>